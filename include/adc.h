// Class for a ADC board
// Copyright (C) 2018 Carlos Kometter 
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

#ifndef ADC_h_
#define ADC_h_

#include "Arduino.h"
#include "SPI.h" 

typedef unsigned char byte;

///
/// Adc class
///
class AdcSpi {
 private:
  // sync_pin_ identifies the adc chip; each chip has a unique sync_pin_.
  // spi_bus_config_pin_ identifies the bus configurations.
  // More than one adc can share the same bus if they use the same spi configs.
  uint8_t sync_pin_, spi_bus_config_pin_, data_ready_pin_, spi_mode_;
  uint8_t clock_divider_;  // For due frequency = 84 MHz / clock_divider_
  BitOrder bit_order_;  // MSBFIRST or LSBFIRST
 public:
  ///
  /// Constructor
  ///
  AdcSpi(uint8_t sync_pin, uint8_t spi_bus_config_pin,
      uint8_t data_ready_pin, uint8_t clock_divider=7,
      BitOrder bit_order=MSBFIRST, uint8_t spi_mode=SPI_MODE3);
  ///
  /// Configures pins for SPI and initializes SPI communication.
  ///
  bool Begin(void);
  ///
  /// Sets a voltage to Dac object via SPI. The message msg_ is generated by calling
  /// VoltageToBytes(), which is specific to each chip.
  ///
  float ReadVoltage(uint8_t channel=0);
 protected:
  ///
  /// struct use as a SPI messsage
  ///
  typedef struct {
    ///
    /// Size of msg. (block_size*n_blocks <= kdata_len_)
    ///
    static const uint8_t kdata_len_ = 10;
    ///
    /// Message to be sent via SPI. Each element represents a byte. This message is
    /// separated coul be divided in blocks. 
    ///
    byte msg[kdata_len_];
    ///
    /// The size in bytes of the registers to be written.
    /// It can be also be think as the number of bytes to be sent before the setting
    /// the sync_pin_ to HIGH. (block_size*n_blocks <= kdata_len_)
    ///
    uint8_t block_size;
    ///
    /// The number of blocks. Each block starts with a sync_pin_ to LOW and ends with
    /// a sync_pin_ to HIGH. (block_size*n_blocks <= kdata_len_)
    ///
    uint8_t n_blocks;
  } Message;
  ///
  /// Uses chip specifications (e.g. bit resolution, registers, range) to convert a
  /// Message to voltage.
  /// Each ADC has its own convertion function. Check the datasheet of each chip
  /// and override the function below accordingly.
  ///
  virtual float BytesToVoltage(Message message) = 0;
  ///
  /// Returns Message object to start single conversion mode.
  ///
  virtual Message SingleConversionModeMessage(uint8_t channel=0) = 0;
  ///
  /// Returns Message object to read the data register.
  ///
  virtual Message ReadDataRegisterMessage(uint8_t channel=0) = 0;
};
#endif
